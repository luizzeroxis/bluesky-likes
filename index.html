<!DOCTYPE html>

<head>
	<title>See other profile's likes on Bluesky</title>
	<meta name="description"
		content="Wanna view the Bluesky likes of another user? This website will allow you to check that using the official Bluesky API." />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="color-scheme" content="light dark" />
	<style>
		body {
			overflow-wrap: anywhere;
		}

		a {
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
		}

		.main {
			font-family: sans-serif;
			font-size: 10pt;
			margin: 0 auto;
			max-width: 600px;
		}

		.header {
			display: flex;
			flex-wrap: wrap;
			justify-content: space-between;
		}

		.profile-form {
			display: flex;
			flex-wrap: wrap;
			justify-content: end;
			align-items: baseline;
			column-gap: 8px;
			margin-top: 8px;
			margin-bottom: 8px;
		}

		.profile {
			flex: 1;
			flex-basis: 100%;
			min-width: 0;
		}

		.posts {
			margin-top: 8px;
			margin-bottom: 8px;
		}

		.like .like-line-1 {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			gap: 8px;
			margin-top: 8px;
			margin-bottom: 8px;
		}

		.like .like-line-1 *:first-child {
			flex: 1;
			flex-basis: auto;
		}

		.post {
			border: 1px solid #808080;
			padding: 8px;
		}

		.post .show-post {
			width: 100%;
		}

		.post .container-1 {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.post .reply-info {}

		.post .container-avatar-main {
			display: flex;
			gap: 8px;
		}

		.post .container-avatar-main>.column-avatar {
			width: 32px;
		}

		.post .container-avatar-main>.column-main {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.post .avatar {
			width: 32px;
			height: 32px;
		}

		.post .line-1 {
			display: flex;
			flex-wrap: wrap;
			align-items: baseline;
			gap: 8px;
		}

		.post .line-1 .display-name {
			white-space-collapse: preserve;
			font-weight: bold;
		}

		.post .text {
			white-space-collapse: preserve;
		}

		.post .embed-images {
			display: flex;
			align-items: center;
		}

		.post .embed-images a {
			flex: 1;
		}

		.post .embed-video {
			position: relative;
		}

		.post .embed-video a::after {
			content: "▶︎";
			position: absolute;
			top: 8px;
			left: 8px;
			opacity: 0.5;
		}

		.post .embed-video a:hover {
			outline: 1px solid #808080;
		}

		.post .embed-external {
			display: flex;
			flex-direction: column;
			gap: 8px;
			padding-bottom: 8px;
			border: 1px solid #808080;
		}

		.post .embed-external .title, .post .embed-external .description {
			white-space-collapse: preserve;
		}

		.post .embed-thumbnail {
			display: block;
			max-height: 600px;
			max-width: 100%;
		}

		.post .line-counts {
			display: flex;
			flex-wrap: wrap;
		}

		.post .line-counts div {
			flex: 1;
		}

		.final {
			text-align: center;
			margin-top: 8px;
			margin-bottom: 8px;
		}
	</style>
</head>

<body>
	<div class="main">
		<div class="header">
			<strong>See other profile's likes on Bluesky</strong>
			<a href="https://github.com/luizzeroxis/bluesky-likes/">Source code - GPLv3</a>
		</div>
		<form class="profile-form">
			<input class="profile" type="text" placeholder="https://bsky.app/profile/handle.bsky.social" />
			<label><input class="reverse" type="checkbox" />Oldest first</label>
			<label><input class="show-hidden" type="checkbox" />Show adult/hidden</label>
			<select class="display-method" title="Method to use to display posts.">
				<option value="embed" title="Use embeded iframes from Bluesky. Slow.">Embed</option>
				<option value="custom"
					title="Use my custom renderer. Faster, but may not accurately display some posts.">Custom</option>
			</select>
			<div>
				<button class="show-likes">Show likes</button>
			</div>
		</form>
		<div class="posts">
			<div class="pages"></div>
			<div class="final"></div>
		</div>
	</div>

	<script>
let abortController = null;

let profile;
let reverse = false;
let showHidden = false;
let useEmbeds = true;
let useCustom = false;

// Main

const main = async () => {
	// Check query string
	if (location.search != "") {
		let searchParams = new URLSearchParams(location.search);

		const setSearchBool = (name, previousValue, trueValue = 'true', falseValue = 'false') => {
			let param = searchParams.get(name);
			return param == trueValue ? true
				: param == falseValue ? false
				: previousValue;
		}

		reverse = setSearchBool('reverse', reverse);
		$('.reverse').checked = reverse;

		showHidden = setSearchBool('showhidden', showHidden);
		$('.show-hidden').checked = showHidden;

		useEmbeds = setSearchBool('method', useEmbeds, 'embed', 'custom');
		useCustom = setSearchBool('method', useCustom, 'custom', 'embed');
		$('.display-method').value = useEmbeds ? 'embed' : useCustom ? 'custom' : null;

		if (searchParams.has('profile')) {
			profile = searchParams.get('profile');
			$('.profile').value = profile;

			profile = parseProfile(profile);
			if (profile == null) return;

			await abortWrapper(load);
		}
	}

	$('.profile-form').onsubmit = async e => {
		e.preventDefault();

		profile = parseProfile($('.profile').value);
		if (profile == null) return;

		reverse = $('.reverse').checked;
		showHidden = $('.show-hidden').checked;

		let displayMethod = $('.display-method').value;
		if (displayMethod == 'embed') {
			useEmbeds = true;
			useCustom = false;
		} else if (displayMethod == 'custom') {
			useEmbeds = false;
			useCustom = true;
		}

		await abortWrapper(load);
	}
}

const parseProfile = (input) => {
	if (input.startsWith('http://') || input.startsWith('https://')) {
		input = input.split('//')[1];
	}
	if (input.startsWith('bsky.app/profile/')) {
		input = input.slice('bsky.app/profile/'.length);
	}
	if (input == "") return null;

	console.log(input);
	return input;
}

const load = async () => {
	abortController.signal.addEventListener('abort', e => {
		$('.final').textContent = "Request cancelled";
	});

	$('.pages').replaceChildren();

	await appendLikesWithMore();
}

const appendLikesWithMore = async (cursor) => {
	try {
		$('.final').textContent = "Loading...";

		cursor = await appendLikes(cursor);

		if (cursor) {
			let loadMoreLikesElem = html('button', {}, 'Load more likes');
			loadMoreLikesElem.onclick = async () => {
				await abortWrapper(async () => {
					abortController.signal.addEventListener('abort', e => {
						$('.final').textContent = "Request cancelled";
					});

					await appendLikesWithMore(cursor);
				});
			};
			$('.final').replaceChildren(loadMoreLikesElem);
		} else {
			$('.final').textContent = "End of likes";
		}
	} catch (e) {
		if (e instanceof NotOkError) {
			$('.final').textContent = `Error when fetching likes: ${e.message}`;
		} else {
			throw e;
		}
	}
}

const appendLikes = async (cursor) => {
	// com.atproto.repo.listRecords
	let likes = await apiRequest("https://bsky.social/xrpc/com.atproto.repo.listRecords", {
		repo: profile,
		collection: "app.bsky.feed.like",
		...(cursor ? { cursor } : {}),
		limit: 25,
		reverse: reverse,
	});

	console.log(likes);

	let pageElem = $('.pages').appendChild(html("div", { class: "page" }));

	let posts = [];
	if (useCustom) {
		// likeRecord.value => app.bsky.feed.like
		let postUris = likes.records
			.map(likeRecord => likeRecord.value.subject.uri)
			.filter(uri => parseUri(uri).collection == "app.bsky.feed.post");

		console.log(postUris);

		// app.bsky.feed.getPosts
		// posts.posts[] => app.bsky.feed.defs#postView
		if (postUris.length > 0) {
			posts = await apiRequest("https://public.api.bsky.app/xrpc/app.bsky.feed.getPosts", {
				uris: postUris,
			});
		}

		console.log(posts);
	}

	for (let likeRecord of likes.records) {
		let likeElem = pageElem.appendChild(html('div', { class: "like" }));

		let likeLine1 = likeElem.appendChild(html('div', { class: 'like-line-1' }, [
			html('div', { class: 'liked-at' }, `Liked at ${toUserDate(likeRecord.value.createdAt)}:`),
		]));

		if (useCustom) {
			let post = posts.posts.find(post => post.uri == likeRecord.value.subject.uri);
			let collection = parseUri(likeRecord.value.subject.uri).collection;

			if (collection == "app.bsky.feed.post") {
				if (post) {
					likeElem.append(makePostView(post));
				} else {
					likeElem.append(html('div', { class: 'post' },
						html('a', { href: toPostUri(likeRecord.value.subject.uri) }, `Post not found, it may have been deleted.`)));
				}
			} else {
				likeElem.append(html('div', { class: 'post' }, `Unsupported collection type ${likeRecord.value.subject.uri}`));
			}
		}
		if (useEmbeds) {
			let uri = parseUri(likeRecord.value.subject.uri);
			let embed = likeElem.appendChild(makeEmbed(likeRecord.value.subject));

			let reloadEmbedButton = html('button', { title: 'Reload embed' }, '🔄︎');
			reloadEmbedButton.addEventListener('click', () => {
				embed.replaceChildren(makeEmbed(likeRecord.value.subject));
			})

			likeLine1.append(
				html('a', { href: toPostUri(likeRecord.value.subject.uri) }, 'Open on bsky.app'),
				reloadEmbedButton,
			);
		}
	}

	return likes.cursor;
}

const makePostView = (postView) => {
	return makePost(postView, postView.record, postView.embed);
}

const makePost = (post, record, embeds) => {
	let container1Elem = html('div', { class: 'container-1' }, [
		makeReplyInfo(record),

		html('div', { class: 'container-avatar-main' }, [
			html('div', { class: 'column-avatar' }, post.author.avatar ?
				html('a', { href: toProfileUri(post.author.did) },
					html('img', { class: 'avatar', src: post.author.avatar })) : null),

			html('div', { class: 'column-main' }, [
				html('div', { class: 'line-1' }, [
					html('a', { href: toProfileUri(post.author.did) },
						html('div', { class: 'display-name' }, post.author.displayName ?? "No display name")),
					html('a', { href: toProfileUri(post.author.handle) },
						html('div', { class: 'handle' }, "@" + post.author.handle)),
					html('div', { class: 'created-at' },
						html('a', { href: toPostUri(post.uri) }, toUserDate(record.createdAt))),
				]),

				html('div', { class: 'text' }, toRichText(record.text, record.facets ?? [])),
				...makePostEmbeds(embeds, post),

				html('div', { class: 'line-counts' }, [
					html('div', { title: `${post.replyCount} replies` }, `💬 ${post.replyCount}`),
					html('div', { title: `${(post.repostCount + post.quoteCount)} reposts and quotes` }, `🔁 ${(post.repostCount + post.quoteCount)}`),
					html('div', { title: `${post.likeCount} likes` }, `❤️ ${post.likeCount}`),
				]),
			]),
		]),
	]);

	let hide = shouldHidePost(post);
	if (hide) {
		container1Elem.style.display = 'none';

		let buttonElem = html('button', { class: 'show-post' }, `Show post (${hide})`);
		buttonElem.addEventListener('click', () => {
			container1Elem.style.display = 'block';
			buttonElem.remove();
		});

		return html('div', { class: 'post' }, [
			buttonElem,
			container1Elem,
		]);
	} else {
		return html('div', { class: 'post' }, container1Elem);
	}
}

const makeReplyInfo = (post) => {
	if (!post.reply) return;
	return html('a', { href: toPostUri(post.reply.parent.uri) }, '⤷ Replying to post');
}

const makePostEmbeds = (postEmbeds, post) => {
	if (!postEmbeds) return [];
	if (!Array.isArray(postEmbeds)) {
		postEmbeds = [postEmbeds]
	}

	return postEmbeds.flatMap(postEmbed => {
		if (postEmbed.$type == 'app.bsky.embed.images#view') {
			return html('div', { class: 'embed-images' }, postEmbed.images.map(image =>
				html('a', { href: image.fullsize }, html('img', { class: 'embed-thumbnail', src: image.thumb, alt: image.alt, title: image.alt }))
			));
		} else if (postEmbed.$type == 'app.bsky.embed.video#view') {
			return html('div', { class: 'embed-video' },
				html('a', { href: toPostUri(post.uri), title: 'Video' }, html('img', { class: 'embed-thumbnail', src: postEmbed.thumbnail }))
			);
		} else if (postEmbed.$type == 'app.bsky.embed.external#view') {
			return html('div', { class: 'embed-external' }, [
				postEmbed.external.thumb ? html('a', { href: postEmbed.external.uri },
					html('img', {class: 'embed-thumbnail', src: postEmbed.external.thumb})) : null,
				html('a', { class: 'title', href: postEmbed.external.uri }, postEmbed.external.title),
				html('div', { class: 'description' }, postEmbed.external.description),
				html('a', { href: postEmbed.external.uri }, postEmbed.external.uri),
			]);
		} else if (postEmbed.$type == 'app.bsky.embed.record#view') {
			return makeEmbedRecordView(postEmbed.record);
		} else if (postEmbed.$type == 'app.bsky.embed.recordWithMedia#view') {
			return [
				...makePostEmbeds(postEmbed.media, post),
				// postEmbed.record => app.bsky.embed.record
				// postEmbed.record.record => app.bsky.embed.record#view (probably)
				makeEmbedRecordView(postEmbed.record.record),
			];
		} else {
			return html('div', {}, `Unsupported embed type ${postEmbed.$type}`);
		}
	});
}

const makeEmbedRecordView = (embedRecordView) => {
	// TODO https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/embed/record.json
	if (embedRecordView.$type == 'app.bsky.embed.record#viewRecord') {
		return makePost(embedRecordView, embedRecordView.value, embedRecordView.embeds);
	} else {
		return html('div', {}, `Unsupported record view type ${embedRecordView.$type}`);
	}
}

const shouldHidePost = (post) => {
	if (showHidden) return false;
	if (!post.labels) return false;

	let values = [];
	for (let label of post.labels) {
		if (['!hide', '!warn', '!no-unauthenticated', 'porn', 'sexual', 'graphic-media', 'nudity', 'sexual-figurative'].includes(label.val)) {
			if (!label.neg) {
				values.push(label.val);
			} else {
				values = values.filter(x => x != label.val);
			}
		} else {
			console.log(post, label);
		}
	}

	if (values.length > 0) {
		return values.join(", ");
	}

	return false;
}

const makeEmbed = (post) => {
	return html('div', {}, [
		html('blockquote', {
			'data-bluesky-uri': post.uri,
			'data-bluesky-cid': post.cid,
		}, `Loading ${post.uri} embed...`),
		html('script', {
			src: "https://embed.bsky.app/static/embed.js",
			charset: "utf-8",
			async: "async",
		})
	]);
}

// Bluesky utils

const apiRequest = async (endpoint, args) => {
	args = Object.entries(args).flatMap(([k, v]) => {
		if (Array.isArray(v)) {
			return v.map(x => [k, x]);
		}
		return [[k, v]];
	})
	let url = endpoint + "?" + new URLSearchParams(args);
	let res = await fetch(url, { signal: abortController.signal });
	if (!res.ok) throw new NotOkError(`${res.status}`);
	let json = await res.json();
	return json;
}

const toUserDate = (datetime) => datetime ? new Date(datetime).toLocaleString() : "Unknown time";

const toRichText = (text, facets) => {
	let elems = [];
	let lastByte = 0;

	let array = new TextEncoder().encode(text);
	let textDecoder = new TextDecoder();

	const slice = (start, end) => textDecoder.decode(array.slice(start, end));

	for (let facet of facets) {
		// add in previous text only
		elems.push(slice(lastByte, facet.index.byteStart));

		// add current facet
		let current = slice(facet.index.byteStart, facet.index.byteEnd);
		for (let feature of facet.features) {
			if (feature.$type == "app.bsky.richtext.facet#mention") {
				elems.push(html('a', { href: toProfileUri(feature.did) }, current));
			} else if (feature.$type == "app.bsky.richtext.facet#link") {
				elems.push(html('a', { href: feature.uri, title: feature.uri }, current));
			} else if (feature.$type == "app.bsky.richtext.facet#tag") {
				elems.push(html('a', { href: toTagUri(feature.tag) }, current));
			} else {
				elems.push(html('span', { title: `Unsupported facet ${feature.$type}` }, current));
			}
		}
		lastByte = facet.index.byteEnd;
	}

	elems.push(slice(lastByte, array.length));
	return elems;
}

const parseUri = (uri) => {
	return {
		repo: uri.split("/")[2],
		collection: uri.split("/")[3],
		rkey: uri.split("/")[4],
	};
}

const toProfileUri = (did) => {
	return `https://bsky.app/profile/${did}`;
}

const toPostUri = (uri) => {
	let at = parseUri(uri);
	let collection = (at.collection == "app.bsky.feed.post") ? "post" : "";
	return `https://bsky.app/profile/${at.repo}/post/${at.rkey}`;
}

const toTagUri = (tag) => {
	return `https://bsky.app/tag/${tag}`;
}

// Helpers

const $ = q => document.querySelector(q);

const html = (tag, attrs, contents) => {
	const e = document.createElement(tag);
	if (attrs) {
		for (let [attrName, attrValue] of Object.entries(attrs)) {
			e.setAttribute(attrName, attrValue);
		}
	}
	if (contents) {
		if (!Array.isArray(contents))
			contents = [contents];
		e.append(...contents.filter(x => x));
	}
	return e;
}

const abortWrapper = async (func) => {
	abortController?.abort();

	try {
		abortController = new AbortController();
		await func();
		abortController = null;
	} catch (e) {
		if (e.name == "AbortError") {
			// console.log("aborted", e);
		} else {
			throw e;
		}
	}
}

class NotOkError extends Error { }

main();
	</script>
</body>